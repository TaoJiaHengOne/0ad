//-----------------------------------------------------------------------------
// Premake - gnu.c
//
// GNU tool target.
//
// Copyright (C) 2002-2004 by Jason Perkins
// Source code licensed under the GPL, see LICENSE.txt for details.
//
// $Id: gnu.c,v 1.26 2004/05/05 23:23:44 jason379 Exp $
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include "project.h"
#include "util.h"

#define MAKEFILE_EXT   ".make"
#define OBJECTS_DIR    "obj"
#define OBJECTS_EXT    ".o"

extern const char** commandLineArgs;
extern const char* rootProjectFile;
extern const char* cc;
extern const char* dotnet;
extern int verbose;

static int writeRootMakefile();
static int writeCppPackage(Package* package);
static int writeCsPackage(Package* package);

//-----------------------------------------------------------------------------

int makeGnuScripts()
{
	int i;

	puts("Generating GNU makefiles:");
	
	if (!writeRootMakefile())
		return 0;

	for (i = 0; i < project->numPackages; ++i)
	{
		int result;
		Package* package = project->package[i];
		const char* language = package->language;

		printf("...%s\n", package->name);

		if (strcmp(language, "c#") == 0)
			result = writeCsPackage(package);
		else if (strcmp(language, "c++") == 0 || strcmp(language, "c") == 0)
			result = writeCppPackage(package);
		else
		{
			printf("** Error: unrecognized language '%s'\n", language);
			return 0;
		}

		if (!result) return 0;
	}

	return 1;
}

//-----------------------------------------------------------------------------

static const char* checkDeps(const char* ref, void* data)
{
	int i;
	for (i = 0; i < project->numPackages; ++i)
	{
		if (strcmp(project->package[i]->name, ref) == 0)
			return project->package[i]->name;
	}
	return NULL;
}

static int writeRootMakefile()
{
	int i;
	FILE* file;

	file = openFile(project->path, "Makefile", "");
	if (file == NULL)
	{
		puts("Error: unable to open Makefile\n");
		return 0;
	}

	// Print the header, showing the possible build configurations

	fprintf(file, "# Makefile autogenerated by premake\n");
	fprintf(file, "# Options:\n");
	fprintf(file, "#   CONFIG=[");
	for (i = 0; i < project->package[0]->numConfigs; ++i)
	{
		if (i > 0) fprintf(file, "|");
		fprintf(file, project->package[0]->config[i]->name);
	}
	
	fprintf(file, "]\n\n");

	// Set a default build config if none specified
	
	fprintf(file, "ifndef CONFIG\n");
	fprintf(file, "  CONFIG=%s\n", project->package[0]->config[0]->name);
	fprintf(file, "endif\n\n");
	fprintf(file, "export CONFIG\n\n");
	
	// List all of the available make targets

	fprintf(file, ".PHONY: all clean");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Make rules

	fprintf(file, "all:");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Target to regenerate the makefiles when the premake scripts change

	fprintf(file, "Makefile: %s%s", reversePath(project->path, ".", UNIX), rootProjectFile);
	for (i = 0; i < project->numPackages; ++i)
	{
		if (project->package[i]->script != NULL)
			fprintf(file, " %s%s", reversePath(project->path, ".", UNIX), project->package[i]->script);
	}
	fprintf(file, "\n");
	fprintf(file, "\t@echo ==== Regenerating Makefiles ====\n");
	fprintf(file, "\t@premake");
	for (i = 1; args[i] != NULL; ++i)
		fprintf(file, " %s", args[i]);
	fprintf(file, "\n\n");

	// Individual package targets

	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];
		
		fprintf(file, "%s:", package->name);
			writeList(file, package->config[0]->links, " ", "", "", checkDeps, NULL);
			fprintf(file, "\n");

		fprintf(file, "\t@echo ==== Building %s ====\n", package->name);
		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s ", reversePath(project->path, package->path, UNIX));
		fprintf(file, "-f %s%s\n", package->name, MAKEFILE_EXT);
		fprintf(file, "\n");
	}
	
	fprintf(file, "clean:\n");
	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];

		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s ", reversePath(project->path, package->path, UNIX));
		fprintf(file, "-f %s%s clean\n", package->name, MAKEFILE_EXT);
	}
	
	fclose(file);
	return 1;
}

//-----------------------------------------------------------------------------

static const char* checkCppSources(const char* file, void* data)
{
	if (isCppFile(file))
		return replaceExtension(getFilename(file,0), OBJECTS_EXT);
	return NULL;
}

static const char* checkCppFlags(const char* flag, void* data)
{
	char* cc = (char*)data;

	if (strcmp(flag, "with-symbols") == 0)
		return "-g";
	else if (strcmp(flag, "optimize-size") == 0)
		return "-Os";
	else if (strcmp(flag, "optimize-speed") == 0)
		return "-O3";
	else if (strcmp(flag, "no-rtti") == 0 && strcmp(cc, "C++") == 0)
		return "--no-rtti";
	else if (strcmp(flag, "no-exceptions") == 0 && strcmp(cc, "C++") == 0)
		return "--no-exceptions";
	else
		return NULL;
}

static void writeSourcePaths(FILE* file, const char* path, int stage)
{
	if (stage == WST_OPENGROUP && strlen(path) > 0)
		fprintf(file, " %s", path);
}

static const char* checkLink(const char* path, void* data)
{
	Package* package = getPackage(path);
	if (package == NULL) return path;

	if (strcmp(package->language, "c++") == 0 || strcmp(package->language, "c") == 0)
		return package->config[*((int*)data)]->target;
	
	return NULL;
}

static int writeCppPackage(Package* package)
{
	const char* prefix = (verbose) ? "" : "@";

	char buffer[4096];
	const char* cflags;
	const char* ldflags;
	FILE* file;
	int i;

	const char* name = package->name;
	const char* path = package->path;
	const char* kind = package->kind;
	
	const char* location;

	// Set up the flags specific to the type of binary being built

	cflags = "";
	ldflags = "";
	location = "$(BINDIR)";

	if (strcmp(kind, "exe") == 0 || strcmp(kind, "winexe") == 0)
	{
		/* defaults are fine */
	}
	else if (strcmp(kind, "dll") == 0)
	{
		if (strcmp(osIdent, "windows") != 0)
			cflags = " -fPIC";
		if (cc == NULL || strcmp(cc, "gcc") == 0)
			ldflags = " -shared";
	}
	else if (strcmp(kind, "lib") == 0)
	{
		location = "$(LIBDIR)";
	}
	else
	{
		printf("** Error: unknown package type '%s'\n", kind);
		return 0;
	}

	// Open package makefile and write the header

	file = openFile(path, name, MAKEFILE_EXT);
	if (file == NULL) return 0;

	fprintf(file, "# Sub-makefile autogenerated by premake\n\n");
	
	// Build bin and lib paths, trim off trailing slash
	strcpy(buffer, reversePath(path, project->binaries, UNIX));
	buffer[strlen(buffer)-1] = '\0';
	fprintf(file, "BINDIR = %s\n", buffer);
  
	strcpy(buffer, reversePath(path, project->libraries, UNIX));
	buffer[strlen(buffer)-1] = '\0';
	fprintf(file, "LIBDIR = %s\n\n", buffer);

	fprintf(file, "CFLAGS =%s\n", cflags);
	fprintf(file, "LDFLAGS = -L$(BINDIR) -L$(LIBDIR)%s\n", ldflags);
	fprintf(file, "TARGET =\n");
	if (strcmp(osIdent, "macosx") == 0 && strcmp(kind, "winexe") == 0)
		fprintf(file, "MACAPP = \n");
	fprintf(file, "\n");

	// Process the build configurations

	for (i = 0; i < package->numConfigs; ++i)
	{
		Config* config = package->config[i];
		fprintf(file, "ifeq ($(CONFIG),%s)\n", config->name);
		
		fprintf(file, "  CFLAGS +=");
		writeList(file, config->buildOptions, " ", "", "", NULL, "C");
		writeList(file, config->buildFlags, " ", "", "", checkCppFlags, "C");

		if (strcmp(osIdent, "windows") == 0)
			fprintf(file, " -D_WIN32");
		writeList(file, config->defines, " -D \"", "\"", "", NULL, NULL);
		writeList(file, config->includePaths, " -I ",   "", "", NULL, NULL);
		fprintf(file, "\n");

		fprintf(file, "  CXXFLAGS = $(CFLAGS)");
		writeList(file, config->buildOptions, " ", "", "", NULL, "C++");
		writeList(file, config->buildFlags, " ", "", "", checkCppFlags, "C++");
		fprintf(file, "\n");

		fprintf(file, "  LDFLAGS +=");
		writeList(file, config->linkOptions, " ", "", "", NULL, NULL);
		writeList(file, config->linkFlags, " ", "", "", NULL, NULL);
		writeList(file, config->libPaths, " -L ", "", "", NULL, NULL);
		writeList(file, config->links, " -l", "", "", checkLink, &i);
		fprintf(file, "\n");

		fprintf(file, "  TARGET = ");
		if (strcmp(kind, "winexe") == 0 || strcmp(kind, "exe") == 0)
		{
			if (strcmp(kind, "winexe") == 0 && strcmp(osIdent, "macosx") == 0)
			{
				fprintf(file, "%s.app/Contents/MacOS/%s\n", config->target, config->target);
				fprintf(file, "  MACAPP = %s\n", config->target);
			}
			else
			{
				fprintf(file, "%s\n", config->target);
			}
		}
		else
		{
			fprintf(file, "%s/", getDirectory(config->target));
			if (strcmp(kind, "lib") == 0)
			{
				fprintf(file, "lib%s.a\n", getFilename(config->target, 0));
			}
			else
			{
				if (strcmp(osIdent, "windows") == 0)
					fprintf(file, "%s.dll\n", getFilename(config->target, 0));
				else
					fprintf(file, "lib%s.so\n", getFilename(config->target, 0));
			}
		}

		fprintf(file, "endif\n");
	}

	fprintf(file, "\n");

	// These rules auto-create dependency lists (see "Advanced Auto-Dependency
	// Generation at http://www.paulandlesley.org/gmake/autodep.html) and place
	// the *.P and *.o files in $(OBJ_DIR)

	// Note all of these targets do the same thing. Is there a way to reuse the
	// command block? Didn't see anything in the make manual, though it would
	// seem this is something people would want to do.

	for (i = 0; CPP_EXT[i]; ++i)
	{
		fprintf(file, "%s/%%.o : %%%s\n", OBJECTS_DIR, CPP_EXT[i]);
		fprintf(file, "\t-%sif [ ! -d %s ]; then mkdir %s; fi\n", prefix, OBJECTS_DIR, OBJECTS_DIR);
		if (!verbose)
			fprintf(file, "\t@echo $(notdir $<)\n");

		if (cc != NULL && strcmp(cc, "dmc") == 0)
		{
			if (strcmp(CPP_EXT[i], ".c") == 0)
				fprintf(file, "\t%sdmc $(CFLAGS) -o $@ -c $<\n", prefix);
			else if (strcmp(CPP_EXT[i], ".asm") != 0)
				fprintf(file, "\t%sdmc -cpp -Ae -Ar -mn -D_WINDOWS $(CXXFLAGS) -o $@ -c $<\n", prefix);
		}
		else
		{
			if (strcmp(CPP_EXT[i], ".c") == 0)
				fprintf(file, "\t%s$(CC) $(CFLAGS) -MD -o $@ -c $<\n", prefix);
			else if (strcmp(CPP_EXT[i], ".asm") == 0)
			{
				/*	nasm -f elf -o $@ $<
					nasm -M -o $@ $< >OBJ_DIR/$*.P */
				fprintf(file, "\t%snasm -f elf -o $@ $<\n", prefix);
				fprintf(file, "\t%snasm -M -o $@ $< >$*.d\n", prefix);
			}
			else
				fprintf(file, "\t%s$(CXX) $(CXXFLAGS) -MD -o $@ -c $<\n", prefix);
		}

		fprintf(file, "\t-%sif [ -f $*.d ]; then mv $*.d obj/$*.d; fi\n", prefix);
		fprintf(file, "\t%scp %s/$*.d %s/$*.P; \\\n", prefix, OBJECTS_DIR, OBJECTS_DIR);
		fprintf(file, "\t sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\\\$$//' \\\n");
		fprintf(file, "\t -e '/^$$/ d' -e 's/$$/ :/' < %s/$*.d >> %s/$*.P; \\\n", OBJECTS_DIR, OBJECTS_DIR);
		fprintf(file, "\trm -f %s/$*.d\n\n", OBJECTS_DIR);
	}
	
	// Write out the list of object file targets for all C/C++ sources

	fprintf(file, "OBJECTS = \\\n");
	writeList(file, package->files, "\tobj/", " \\\n", "", checkCppSources, NULL);
	fprintf(file, "\n");

	// Write out the list of source directories

	fprintf(file, "VPATH =");
	walkSourceList(file, package, "", writeSourcePaths);
	fprintf(file, "\n\n");

	fprintf(file, ".PHONY: clean\n");
	fprintf(file, "\n");

	if (strcmp(osIdent, "macosx") == 0 && strcmp(kind, "winexe") == 0)
	{
		fprintf(file, "all: $(BINDIR)/$(MACAPP).app/Contents/PkgInfo $(BINDIR)/$(MACAPP).app/Contents/Info.plist $(BINDIR)/$(TARGET)\n\n");
	}

	fprintf(file, "%s/$(TARGET): $(OBJECTS)\n", location);
	fprintf(file, "\t@echo Linking %s\n", package->name);
	fprintf(file, "\t-%sif [ ! -d $(BINDIR) ]; then mkdir -p $(BINDIR); fi\n", prefix);
	fprintf(file, "\t-%sif [ ! -d $(LIBDIR) ]; then mkdir -p $(LIBDIR); fi\n", prefix);
	if (strcmp(osIdent, "macosx") == 0 && strcmp(kind, "winexe") == 0)
		fprintf(file, "\t-%sif [ ! -d $(BINDIR)/$(MACAPP).app/Contents/MacOS ]; then mkdir -p $(BINDIR)/$(MACAPP).app/Contents/MacOS; fi\n", prefix);

	if (strcmp(kind, "lib") == 0)
	{
		fprintf(file, "\t%sar -cr $@ $^\n", prefix);
		fprintf(file, "\t%sranlib $@\n", prefix);
	}
	else
	{
		fprintf(file, "\t%s$(CXX) -o $@ $(filter-out %%.so, $^) $(LDFLAGS)\n", prefix);
	}
	fprintf(file, "\n");

	if (strcmp(osIdent, "macosx") == 0 && strcmp(kind, "winexe") == 0)
	{
		fprintf(file, "$(BINDIR)/$(MACAPP).app/Contents/PkgInfo:\n");
		fprintf(file, "\n");

		fprintf(file, "$(BINDIR)/$(MACAPP).app/Contents/Info.plist:\n");
		fprintf(file, "\n");
	}

	fprintf(file, "clean:\n");
	fprintf(file, "\t@echo Cleaning %s\n", package->name);
	if (strcmp(osIdent, "macosx") == 0 && strcmp(kind, "winexe") == 0)
	{
		fprintf(file, "\t-%srm -rf %s/$(MACAPP).app %s/*\n", prefix, location, OBJECTS_DIR);
	}
	else
	{
		fprintf(file, "\t-%srm -rf %s/$(TARGET) %s/*\n", prefix, location, OBJECTS_DIR);
	}
	fprintf(file, "\n");

	fprintf(file, "-include $(OBJECTS:%%.o=%%.P)\n\n");

	fclose(file);
	return 1;
}

//-----------------------------------------------------------------------------

static const char* checkReferences(const char* file, void* data)
{
	Package* package = getPackage(file);
	if (package == NULL) return file;
	if (strcmp(package->language, "c#") != 0) return NULL;
	return package->config[*((int*)data)]->target;
}

static const char* checkCsSources(const char* file, void* data)
{
	if (strcmp(getExtension(file), ".cs") == 0)
		return file;
	return NULL;
}

static int writeCsPackage(Package* package)
{
	const char* extension;
	const char* csc;
	FILE* file;
	int i;

	// Figure out what I'm building

	const char* name = package->name;
	const char* path = package->path;
	const char* kind = package->kind;

	if (strcmp(kind, "dll") == 0 || strcmp(kind, "aspnet") == 0)
	{
		extension = ".dll";
		kind = "library";
	}
	else if (strcmp(kind, "winexe") == 0 || strcmp(kind, "exe") == 0)
	{
		extension = ".exe";
	}
	else
	{
		printf("** Error: unknown package type '%s'\n", kind);
		return 0;
	}

	// Figure out what I'm building it with

	if (dotnet == NULL)
	{
		if (strcmp(osIdent, "windows") == 0)
			csc = "csc /nologo";
		else
			csc = "mcs";
	}
	else if (strcmp(dotnet, "ms") == 0)
		csc = "csc";
	else if (strcmp(dotnet, "pnet") == 0)
		csc = "cscc";
	else if (strcmp(dotnet, "mono") == 0)
		csc = "mcs";
	else
	{
		printf("** Error: unknown .NET runtime '%s'\n", dotnet);
		return 0;
	}

	// Open the package Makefile and write the header

	file = openFile(path, name, MAKEFILE_EXT);
	if (file == NULL)
		return 0;

	fprintf(file, "# Sub-makefile autogenerated by premake\n\n");

	fprintf(file, "BINDIR = %s\n\n", reversePath(path, project->binaries, UNIX));
	
	fprintf(file, "FLAGS =\n");
	fprintf(file, "TARGET =\n\n");

	// Process the build configurations

	for (i = 0; i < package->numConfigs; ++i)
	{
		Config* config = package->config[i];
		int symbols = !inArray(config->buildFlags,"no-symbols");
		int optimize = inArray(config->buildFlags,"optimize")||inArray(config->buildFlags,"optimize-size")||inArray(config->buildFlags,"optimize-speed");
		int unsafe = inArray(config->buildFlags,"unsafe");

		fprintf(file, "ifeq ($(CONFIG),%s)\n", config->name);

		fprintf(file, "  FLAGS +=");
		if (symbols) fprintf(file, " /debug");
		if (unsafe) fprintf(file, " /unsafe");
		writeList(file, config->defines, " /d:", "", "", NULL, NULL);
		writeList(file, config->libPaths, " /lib:", "", "", NULL, NULL);
		writeList(file, config->links, " /r:", ".dll", "", checkReferences, &i);
		fprintf(file, "\n");

		fprintf(file, "  TARGET = %s%s\n", config->target, extension);
		fprintf(file, "endif\n");
	}
	
	// Create the list of files
	
	fprintf(file, "\nSOURCES = \\\n");
	writeList(file, package->files, "\t", " \\\n", "", checkCsSources, NULL);
	fprintf(file, "\n");
	
	// Build targets 

	fprintf(file, "\n.PHONY: clean\n\n");

	fprintf(file, "$(BINDIR)/$(TARGET): $(SOURCES)\n");
	fprintf(file, "\t-@if [ ! -d $(BINDIR) ]; then mkdir -p $(BINDIR); fi\n");
	fprintf(file, "\t@%s /out:$@ /t:%s -lib:$(BINDIR) $(FLAGS) $^\n\n", csc, kind);

	fprintf(file, "clean:\n");
	fprintf(file, "\t@echo Cleaning %s\n", name);
	fprintf(file, "\t-@rm -f  $(BINDIR)/$(TARGET)\n");

	fclose(file);
	return 1;
}
