\documentclass[12pt,a4paper]{article}

\usepackage{parskip}

\usepackage{listings}
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, language=C++, tabsize=4}

\usepackage[linkcolor=black,pdftex]{hyperref}

\newcommand{\id}[1]{\texttt{#1}}

\begin{document}

\title{0 A.D. CODE CONVENTIONS}
\author{Dave Loeser \and Jan Wassenberg}
\maketitle

\tableofcontents

\section{Objective}

The goal of this document is to provide a standardized coding methodology for the 0 A.D. programming team. With but a few guidelines such as Layout-, Commenting- and Naming conventions the team should feel as if they are reading their own code when reading someone else's code.

\section{Layout}

\subsection{Formatting}

Most editors allow for the conversion of tabs to spaces and most people prefer the use of tabs versus wearing out the spacebar. The size of the tabs is up to each programmer –-- just ensure that you are using tabs.

Limit the length of a line of code to not more than 80 characters; not everyone has a 1600x1200 display. Functions that have many parameters and extend over 80 characters should be written as:
\begin{lstlisting}
SomeFunction(
	HWND hWnd, 
	BITMAP bmDeviceBitmap, 
	long lAnimationFrame);
\end{lstlisting}
instead of:
\begin{lstlisting}
SomeFunction(HWND hWnd, 
             BITMAP bmDeviceBitmap, 
             long lAnimationFrame);
\end{lstlisting}
Although the second method is commonly used, it is more difficult to maintain (if the name of the function changed, you would need to re-align the parameters).

\pagebreak
\subsection{Brackets}

Brackets should be aligned, here's an example of good bracket placement:
\begin{lstlisting}
void CGameObject::CleanUp()
{
	if(NULL != m_ThisObject)
	{
		delete m_ThisObject;
	}
}
\end{lstlisting}
Now we're not out to save vertical lines on the screen; it's about being able to read the code. Therefore, the following style should be avoided:
\begin{lstlisting}
void CGameObject::CleanUp() {
	if(NULL != m_ThisObject) {
		delete m_ThisObject;
}
}
\end{lstlisting}

\section{Commenting}

Commenting is a subject that is sure to cause debate, but minimal comments with maximum expressiveness are preferable. Bad commenting style is shown below:
\begin{lstlisting}
void CGameObject::SetModifiedFlag(bool flag)
{
	m_ModifiedFlag = flag;	// set the modified flag
}
\end{lstlisting}
The above comment does not tell us anything that we don't already know from reading the code; here's a better approach:
\begin{lstlisting}
void CGameObject::SetModifiedFlag(bool flag)
{
	// This sets the CGameObject's modified
	// flag, which is used to determine
	// if this object needs to be serialized.
	m_ModifiedFlag = flag;
}
\end{lstlisting}

\section{Documentation}

Each programmer is responsible for properly documenting their code. During code review the code reviewer will ensure that interfaces or APIs are properly documented.

If the comments are formatted in a certain way, they will automatically be extracted and added to the relevant documentation file. It suffices to write them as follows:
\begin{lstlisting}
/**
 * Your comment here.
 **/
\end{lstlisting}
For single-line comments, \lstinline|///| can be used as well. The comment text is inserted into the documentation, and can additionally be formatted by certain tags (e.g. @param \textit{description} for function parameters). For more details, see the CppDoc documentation.

The recommended comment for a class is as follows:
\begin{lstlisting}
/**
 * An object that represents a civilian entity.
 *
 * (Notes regarding usage and possible problems etc...)
 **/
\end{lstlisting}
Each method of a class should be documented as well and here is the suggested method of documenting a member function (continuing with \id{CExample}):
\begin{lstlisting}
class CExample
{
public:
	CExample();
	~CExample():

	/**
	 * This function does nothing, but is a good example of
	 * documenting a member function.
	 * @param dummy A dummy parameter.
	 **/
	void ShowExample(int dummy); 

private:
	intptr_t m_ExampleData;          // Holds the value of this example.
  double m_FairlyLongVariableName; // Shows the lining up of comments
};
\end{lstlisting}
The ctor and dtor need not be commented --- everyone knows what they are and what they do. \id{ShowExample()}, on the other hand, provides a brief comment as to its purpose. You may also want to provide an example of a method's usage. Member data is commented on the right side and it is generally good (when possible) to line up comments for easier reading.

\section{Naming Conventions}

\subsection{Filenames}

Filenames can be freely chosen, but to avoid problems on Unix systems, they should not contain spaces or non-ASCII characters. If the file serves to define one class, e.g. \id{CEntity}, the file would usually be called \texttt{Entity.h}.

\subsection{Namespaces}

Namespaces are used as a mechanism to express logical grouping. 

\subsubsection{Global Scope}

Symbols belonging to the global namespace should be prefixed with \id{::}.
Example: The Win32 function \id{::OutputDebugString()} resides in the global namespace and is written with the scope operator preceding the function name.

\subsection{Classes}

Classes should use concise, descriptive names that easily convey their use.

Classes are named using PascalCase - capitalizing each word within the name visually differentiates them. Example: A class named \id{CGameObject} is preferred over \id{gameObject} or \id{cGameObject}.

\subsection{Functions}

Functions should use concise, descriptive names that provide innate clues as to the functionality they provide.

Global and member functions should be named using PascalCase. Example: A function named \id{SetModifiedFlag()} is preferred over \id{SetFlag()} or \id{setFlag}.

\subsection{Variables}

Variable should use concise, descriptive names that provide innate clues as to the data that the variable represents.

Member variables should be prefixed with \id{m\_}, but both \id{m\_camelCase} and \id{m\_PascalCase} may be used according to personal preference (either way, the prefix ensures clarity). Example: \id{m\_GameObject} is more descriptive than \id{gobj}.

\subsection{Example}

Here is a sample header file layout, \texttt{Example.h}:
\begin{lstlisting}

/**
 * =========================================================================
 * File        : Example.h
 * Project     : 0 A.D.
 * Description : CExample interface file.
 *
 * @author TheProgrammer@email.com
 * =========================================================================
 **/

/*
This interface is difficult to write as it really 
pertains to nothing and serves no purpose other than to 
suggest a documentation scheme.
*/

#ifndef INCLUDED_EXAMPLE
#define INCLUDED_EXAMPLE

#include "utils.h"

/**
 * CExample
 * This serves no purpose other than to 
 * provide an example of documenting a class.
 * Notes regarding usage and possible problems etc...
 **/
class CExample
{
public:
	CExample();
	~CExample():

	/**
	 * This function does nothing, but is a good example of
	 * documenting a member function.
	 * @param dummy A dummy parameter.
	 **/
	void ShowExample(int dummy); 

protected:
	int m_UsefulForDerivedClasses;

private:
	uint8_t m_ExampleData;        // Holds the value of this example.
	int m_RatherLongVariableName; // Shows the lining up of comments
};

#endif	// #ifndef INCLUDED_EXAMPLE
\end{lstlisting}
From the above we can see that header guards are utilized. Header file comment blocks show filename, project and author; a short overview follows. 

The order of declarations ought to be: public followed by protected and finally by private.
 
\section{Standard Template Library}

We will make use of the Standard Template Library (STL). Although we may be capable of coding list, maps and queues ourselves and do so more efficiently. Our goal is to create a game not to recreate an existing library.

Having said that, it may make sense to hide some uses of STL objects behind an interface. This can make the code more readable.

\section{Singletons}

Much debate regarding the use of global variables has been generated over the years so we will not re-enter that discussion. The Singleton design pattern does provide many benefits over that of a pure global variable.

We will make use of the Automatic Singleton Utility as described by Scott Bilas in article 1.3 of the ``Game Programming Gems'', volume I, ``An Automatic Singleton Utility''.

\section{Strings}

A string class has been written, \id{CStr}, that should be used instead of directly using \id{std::string} or using C-style strings (i.e. \lstinline|char*|).

\end{document}