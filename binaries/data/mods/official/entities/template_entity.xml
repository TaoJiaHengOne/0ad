<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>

<Entity Tag="template_entity">
	<Traits extant="true" corpse="template_corpse">
		<Id
			type="true"
			rank="0"
		/>
		<!-- Defaults to no armour -->
		<Armour
			Value="0"
			Crush="0.0"
			Hack="0.0"
			Pierce="0.0"
		/>
		<Health />
	</Traits>
	<Event On="Attack">
	<![CDATA[
		// Attack logic.
		dmg = new DamageType();
		dmg.crush = this.actions.attack.damage * this.actions.attack.crush;
		dmg.hack = this.actions.attack.damage * this.actions.attack.hack;
		dmg.pierce = this.actions.attack.damage * this.actions.attack.pierce;

		evt.target.damage( dmg, this );
	]]>	
	</Event>

	<Event On="TakesDamage">
	<![CDATA[
		// Apply armour and work out how much damage we actually take
		crushDamage = evt.damage.crush - this.traits.armour.value * this.traits.armour.crush;
		if( crushDamage < 0 ) crushDamage = 0;
		pierceDamage = evt.damage.pierce - this.traits.armour.value * this.traits.armour.pierce;
		if( pierceDamage < 0 ) pierceDamage = 0;
		hackDamage = evt.damage.hack - this.traits.armour.value * this.traits.armour.hack;
		if( hackDamage < 0 ) hackDamage = 0;

		totalDamage = evt.damage.typeless + crushDamage + pierceDamage + hackDamage;

		// Minimum of 1 damage
		
		if( totalDamage < 1 ) totalDamage = 1;
		
		this.traits.health.curr -= totalDamage;

		if( this.traits.health.curr <= 0 )
		{
			this.kill();
			if( evt.inflictor )
				console.write( this.traits.id.generic + " got the point of " + evt.inflictor.traits.id.generic + "'s Gladius." );
			else
				console.write( this.traits.id.generic + " died in mysterious circumstances." );
		}
		else if( evt.inflictor && this.actions.attack )
		{
			// If we're not already doing something else, take a measured response - hit 'em back.
			// You know, I think this is quite possibly the first AI code the AI divlead has written
			// for 0 A.D....

			if( this.isIdle() )
				this.order( ORDER_ATTACK, evt.inflictor );
		}
	]]>
	</Event>
	<Event On="TargetChanged">
	<![CDATA[
		// This event lets us know when the user moves his/her cursor to a different unit (provided this
		// unit is selected) - use it to tell the engine what context cursor should be displayed, given
		// the target.

		// Attack iff there's a target, it's our enemy, and we're armed. Otherwise move.
		// ToString is needed because every property is actually an object (though that's usually
		// hidden from you) and comparing an object to any other object in JavaScript (1.5, at least)
		// yields false. ToString converts them to their actual values (i.e. the four character
		// string) first.
		if( evt.target &&
		    this.actions.attack && 
		    ( evt.target.traits.id.civ_code != "gaia" ) &&
		    ( evt.target.traits.id.civ_code.toString() != this.traits.id.civ_code.toString() ) )
			evt.defaultAction = ORDER_ATTACK;
		else
			evt.defaultAction = ORDER_GOTO;
	]]>
	</Event>
	<Event On="PrepareOrder">
	<![CDATA[
		// This event gives us a chance to veto any order we're given before we execute it.
		// Not sure whether this really belongs here like this: the alternative is to override it in
		// subtypes - then you wouldn't need to check tags, you could hardcode results.
		switch( evt.orderType )
		{
		case ORDER_GOTO:
			if( !this.actions.move )
				evt.preventDefault();
			break;
		case ORDER_PATROL:
			if( !this.actions.patrol )
				evt.preventDefault();
			break;	
		case ORDER_ATTACK:
			// If we can't attack, we're not targeting a unit, or that unit is the same civ as us.
			// (Should of course be same /player/ as us - not ready yet.)
			if( !this.actions.attack || 
			    !evt.target || 
			    ( evt.target.traits.id.civ_code.toString() == this.traits.id.civ_code.toString() ) )
				evt.preventDefault();
			break;
		default:
			evt.preventDefault();
		}
	]]>
	</Event>
	<Actions>
	</Actions>
</Entity>